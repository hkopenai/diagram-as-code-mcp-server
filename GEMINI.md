# Project Overview

## Active Context
### Current Work Focus
- Implementing Mermaid.js validation and fixing tools.
- Ensuring proper handling of Mermaid.js syntax.
- Establishing comprehensive error handling for tool execution.
- Documenting API handling strategies and error handling aspects for MCP tools.

#### API Handling Strategies and Error Handling Table
| Tool Name                       | API Handling Strategy Type                          | Validated |
|---------------------------------|----------------------------------------------------|-----------|
| mermaid_js_support              | Type 3 | No        |

This table serves as a reference for current and future development, ensuring that each tool's API interaction and error handling approach is aligned with the defined principles.

### Recent Changes
- Initial project setup and FastMCP server implementation.
- Implemented Mermaid.js support tool.
- Configured `pyproject.toml` for project metadata and dependencies.

### Next Steps
- Implement robust error handling for tool execution.
- Add comprehensive unit and integration tests for the Mermaid.js tools.
- Review all documentation for completeness.
- Establish regular memory bank update process.

### Active Decisions
- Using standardized markdown format for all documentation.
- Maintaining clear separation between different context types.
- Prioritizing documentation completeness before adding details.

### Important Patterns
- Following hierarchical documentation structure.
- Linking related concepts across files.
- Using consistent formatting and headers.

### Learnings
- Memory bank is crucial for maintaining context.
- Documentation should be updated incrementally.
- Clear structure makes information easier to find.

## Product Context

### Purpose
- Provide Mermaid.js validation and fixing tools for MCP clients.
- Address limitations of LLMs with outdated Mermaid.js syntax.
- Ensure correctly formatted and functional diagrams.

### Problems Solved
- Assists in authoring, validating, and fixing Mermaid.js syntax errors.
- Helps LLMs overcome issues with outdated syntax knowledge.

### User Experience
- Seamless integration with MCP clients for Mermaid.js diagramming.
- Tools for validating and correcting diagram syntax.

### Value Proposition
- Improves accuracy and reliability of Mermaid.js diagrams generated by LLMs.
- Reduces manual effort in fixing syntax errors.

## Progress

### What Works
- Core FastMCP server functionality.
- Basic Mermaid.js support tool implemented.
- Stdios and SSE transport modes supported.

### What's Left to Build
- Comprehensive error handling for tool execution.
- Full test coverage for Mermaid.js tools.
- Implementation of additional diagram-as-code tools.
- Caching layer for tool results (if applicable).
- Rate limiting implementation (if applicable).

### Current Status
- Basic functionality for Mermaid.js tools is operational.
- Project structure is set up.
- Documentation is in progress.

### Known Issues
- Limited error handling for tool execution failures.
- No caching implemented yet.
- No rate limiting implemented yet.

### Evolution of Decisions
- Initial focus on Mermaid.js due to common LLM limitations.
- Prioritizing syntax validation and fixing capabilities.

## Project Brief

### Core Requirements
- Provide Mermaid.js validation and fixing tools via MCP interface.
- Offer both stdio and SSE communication modes.
- Maintain API compatibility with FastMCP specification.

### Goals
- Create a reliable diagram-as-code service.
- Enable easy integration with Cline and other MCP clients.
- Provide comprehensive Mermaid.js support.
- Ensure high availability and performance.

### Scope
- Included:
  - Mermaid.js syntax validation and fixing.
- Excluded:
  - Other diagramming languages (to be added in future iterations).
  - Graphical rendering of diagrams.

### Key Stakeholders
- MCP client developers.
- LLM developers.
- Users generating diagrams with Mermaid.js.

### Timeline
- Initial release: v0.1.0 (current).
- Future milestones:
  - Add more diagramming language support.
  - Implement caching and rate limiting.

## System Patterns

### System Architecture
- FastMCP server exposing diagram-as-code tools.
- Modular design with separate tool implementation for each tool.
- Layered architecture:
  1. Interface layer (server.py - FastMCP tools).
  2. Service layer (individual tool files - tool logic).
  3. Data layer (external libraries/APIs - if applicable).

### Key Technical Decisions
- Using FastMCP for standardized tool interface.
- Support for both stdio and SSE transport modes.
- Modular tool structure with separate files for each tool.

### Design Patterns in Use
- Adapter pattern: Tool files adapt external libraries/APIs to MCP interface.
- Facade pattern: Simplified interface to complex diagramming logic.
- Singleton pattern: Single FastMCP server instance.
- Strategy pattern: Different transport modes (stdio/SSE).

### Component Relationships
- `server.py` depends on individual tool files for all tools.
- Tool files depend on external libraries (e.g., for Mermaid.js parsing/validation).
- Both depend on FastMCP framework.
- Independent of specific client implementation.

### Critical Implementation Paths
1. Tool registration in `server.py`.
2. Tool execution logic.
3. Error handling for tool failures.
4. Transport mode selection (stdio/SSE).

## Tech Context

### Technologies Used
- Python 3.10+
- FastMCP framework
- Pytest for testing

### Development Setup
- Python virtual environment recommended.
- Install dependencies: `pip install -e .`
- Run tests: `pytest`

### Technical Constraints
- Requires internet connection for external dependencies (if any).
- Supports Python 3.10+ only.

### Dependencies
- Core:
  - `fastmcp>=2.10.2` (MCP protocol implementation)
- Development:
  - `pytest>=8.2.0` (testing framework)
  - `pytest-cov>=6.1.1` (test coverage)

### Tool Usage Patterns
- Run server in stdio mode: `python -m hkopenai.diagram_as_code_mcp_server`
- Run server in SSE mode: `python -m hkopenai.diagram_as_code_mcp_server --sse`
- Run tests: `pytest tests/`
- Build package: `python -m build`
